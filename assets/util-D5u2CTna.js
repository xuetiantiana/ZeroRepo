const $=(o,h)=>{let n=0;const p=(s,e="root",f="",c=0,l)=>{const t=f?"".concat(f,"/").concat(e):e;if(Array.isArray(s))return s.map(r=>{const a=c+1;return{name:r,feature_path:"".concat(t,"/").concat(r),id:n++,level:a,level1Root:l}});if(typeof s=="object"&&s!==null){const r=[];for(const[a,i]of Object.entries(s))if(Array.isArray(i))r.push({name:a,feature_path:"".concat(t,"/").concat(a),id:n++,level:c,level1Root:l,children:i.map(u=>{const m=c+1;return{name:u,feature_path:"".concat(t,"/").concat(a,"/").concat(u),id:n++,level:m,level1Root:l}})});else if(typeof i=="object"){const u=p(i,a,t,c+1,l);Array.isArray(u)?r.push({name:a,feature_path:"".concat(t,"/").concat(a),id:n++,level:c,level1Root:l,children:u}):r.push({name:a,feature_path:"".concat(t,"/").concat(a),id:n++,level:c,children:u.children||[]})}return r}return{name:s,feature_path:t}};if(o&&o.subtrees&&o.subtrees.length>0){const s=[],e=["Data Engineering","Algorithms","Advanced Modeling Techniques","Workflow"];[...o.subtrees].sort((l,t)=>{const r=e.indexOf(l.name),a=e.indexOf(t.name);return r===-1&&a===-1?0:r===-1?1:a===-1?-1:r-a}).forEach((l,t)=>{if(l.refactored_subtree){const r=l.name||"Subtree_".concat(t+1),a=p(l.refactored_subtree,r,"",2,r),i={name:r,feature_path:"".concat(r),id:n++,level:1,children:a,level1Root:r};s.push(i)}});const c={name:"root",feature_path:"root",id:n++,level:0,children:s,visible:!0};return console.log("!!!!",s),console.log("数据转换完成:",c),console.log("处理了 ".concat(s.length," 个subtree组")),g(c),y(c,h),console.log(c),c}return console.warn("数据格式不正确，使用默认数据"),o};function g(o){function h(n){if(!(!n||!n.name)){if(n.level>2&&n.level!=5){const s=n.name.replace(/\b(And|and)\b/g,"&").split(" ");let e,f=n.level==3?10:8;if(s.length<3&&s.every(l=>l.length<=f))e=s.join("\n");else{const l=(t,r)=>t.includes("-")?t.split("-").map((i,u)=>i.slice(0,r)).join("-"):t.includes("&")?t.split("&").map((i,u)=>i.slice(0,r)).join("&"):t.slice(0,r);if(s.length<=2){let t=n.level==3?4:3;e=s.map(r=>l(r,t)).join("\n")}else e=s.map(t=>l(t,1)).join("")}n.originalName=n.name,n.name=e}n.children&&Array.isArray(n.children)&&n.children.forEach(h)}}h(o)}const y=(o,h)=>{if(!o||!h){console.warn("treeData 或 mapData 为空");return}const n=e=>{e&&(p(e,h),e.children&&Array.isArray(e.children)&&e.children.forEach(f=>n(f)))},p=(e,f)=>{if(!e.feature_path){console.warn("节点缺少 feature_path:",e);return}const c=f.metadata||f,l=e.level1Root||s(e.feature_path);if(c[l]){const t=c[l];if(Array.isArray(t)){const r=t.find(a=>{if(typeof a=="object"&&a!==null){const i=a.feature_path===e.feature_path,u=a.node===e.name;return i||u}return!1});r?(e.metaData=r,console.log("为节点 ".concat(e.name," 找到匹配数据:"),r)):console.log("未找到节点 ".concat(e.name," 的匹配数据, feature_path: ").concat(e.feature_path))}else typeof t=="object"&&t[e.feature_path]&&(e.metaData=t[e.feature_path],console.log("为节点 ".concat(e.name," 找到对象数据:"),t[e.feature_path]))}else console.log("未找到根键 ".concat(l," 在mapData中"))},s=e=>e&&e.split("/").find(c=>c&&c!=="root")||"";return Array.isArray(o)?o.forEach(e=>n(e)):n(o),console.log("节点数据匹配完成"),o};function _(o){if(!o.children||o.children.length===0)return 1;const h=o.children.map(n=>_(n));return 1+Math.max(...h)}export{_ as g,$ as h};
