const v=(i,f)=>{let t=0;const p=(s,e="root",u="",l=0,c)=>{const n=u?"".concat(u,"/").concat(e):e;if(Array.isArray(s))return s.map(r=>{const a=l+1;return{name:r,feature_path:"".concat(n,"/").concat(r),idx:""+t++,level:a,level1Root:c}});if(typeof s=="object"&&s!==null){const r=[];for(const[a,h]of Object.entries(s))if(Array.isArray(h))r.push({name:a,feature_path:"".concat(n,"/").concat(a),idx:""+t++,level:l,level1Root:c,children:h.map(o=>{const m=l+1;return{name:o,feature_path:"".concat(n,"/").concat(a,"/").concat(o),idx:""+t++,level:m,level1Root:c}})});else if(typeof h=="object"){const o=p(h,a,n,l+1,c);Array.isArray(o)?r.push({name:a,feature_path:"".concat(n,"/").concat(a),idx:""+t++,level:l,level1Root:c,children:o}):r.push({name:a,feature_path:"".concat(n,"/").concat(a),idx:""+t++,level:l,children:o.children||[]})}return r}return{name:s,feature_path:n}};if(i&&i.subtrees&&i.subtrees.length>0){const s=[],e=["Data Engineering","Algorithms","Advanced Modeling Techniques","Workflow"];[...i.subtrees].sort((c,n)=>{const r=e.indexOf(c.name),a=e.indexOf(n.name);return r===-1&&a===-1?0:r===-1?1:a===-1?-1:r-a}).forEach((c,n)=>{if(c.refactored_subtree){const r=c.name||"Subtree_".concat(n+1),a=p(c.refactored_subtree,r,"",2,r),h={name:r,feature_path:"".concat(r),idx:""+t++,level:1,children:a,level1Root:r};s.push(h)}});const l={name:"root",feature_path:"root",idx:""+t++,level:0,children:s,visible:!0};return console.log("!!!!",s),console.log("数据转换完成:",l),console.log("处理了 ".concat(s.length," 个subtree组")),g(l),y(l,f),console.log(l),l}return console.warn("数据格式不正确，使用默认数据"),i};function g(i){function f(t){if(!(!t||!t.name)){if(t.level>2&&t.level!=5){const s=t.name.replace(/\b(And|and)\b/g,"&").split(" ");let e,u=t.level==3?10:8;const l=s.length<3&&s.every(n=>n.length<=u);let c=!0;if(l)e=s.join("\n"),c=!1;else{const n=(r,a)=>r.includes("-")?r.split("-").map((o,m)=>o.slice(0,a)).join("-"):r.includes("&")?r.split("&").map((o,m)=>o.slice(0,a)).join("&"):r.slice(0,a);if(s.length<=2){let r=t.level==3?4:3;e=s.map(a=>n(a,r)).join("\n")}else e=s.map(r=>n(r,1)).join("")}t.originalName=t.name,t.name=e,t.hasAbbr=c}t.children&&Array.isArray(t.children)&&t.children.forEach(f)}}f(i)}const y=(i,f)=>{if(!i||!f){console.warn("treeData 或 mapData 为空");return}const t=e=>{e&&(p(e,f),e.children&&Array.isArray(e.children)&&e.children.forEach(u=>t(u)))},p=(e,u)=>{if(!e.feature_path){console.warn("节点缺少 feature_path:",e);return}const l=u.metadata||u,c=e.level1Root||s(e.feature_path);if(l[c]){const n=l[c];if(Array.isArray(n)){const r=n.find(a=>typeof a=="object"&&a!==null?a.feature_path===e.feature_path:!1);r?e.metaData=r:console.log("未找到节点 ".concat(e.name," 的匹配数据, feature_path: ").concat(e.feature_path))}else typeof n=="object"&&n[e.feature_path]&&(e.metaData=n[e.feature_path])}else console.log("未找到根键 ".concat(c," 在mapData中"))},s=e=>e&&e.split("/").find(l=>l&&l!=="root")||"";return Array.isArray(i)?i.forEach(e=>t(e)):t(i),console.log("节点数据匹配完成"),i};function _(i){if(!i.children||i.children.length===0)return 1;const f=i.children.map(t=>_(t));return 1+Math.max(...f)}export{_ as g,v as h};
