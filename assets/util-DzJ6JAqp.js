const v=(i,h)=>{let t=0;const p=(s,e="root",f="",c=0,l)=>{const n=f?"".concat(f,"/").concat(e):e;if(Array.isArray(s))return s.map(r=>{const a=c+1;return{name:r,feature_path:"".concat(n,"/").concat(r),id:t++,level:a,level1Root:l}});if(typeof s=="object"&&s!==null){const r=[];for(const[a,o]of Object.entries(s))if(Array.isArray(o))r.push({name:a,feature_path:"".concat(n,"/").concat(a),id:t++,level:c,level1Root:l,children:o.map(u=>{const m=c+1;return{name:u,feature_path:"".concat(n,"/").concat(a,"/").concat(u),id:t++,level:m,level1Root:l}})});else if(typeof o=="object"){const u=p(o,a,n,c+1,l);Array.isArray(u)?r.push({name:a,feature_path:"".concat(n,"/").concat(a),id:t++,level:c,level1Root:l,children:u}):r.push({name:a,feature_path:"".concat(n,"/").concat(a),id:t++,level:c,children:u.children||[]})}return r}return{name:s,feature_path:n}};if(i&&i.subtrees&&i.subtrees.length>0){const s=[],e=["Data Engineering","Algorithms","Advanced Modeling Techniques","Workflow"];[...i.subtrees].sort((l,n)=>{const r=e.indexOf(l.name),a=e.indexOf(n.name);return r===-1&&a===-1?0:r===-1?1:a===-1?-1:r-a}).forEach((l,n)=>{if(l.refactored_subtree){const r=l.name||"Subtree_".concat(n+1),a=p(l.refactored_subtree,r,"",2,r),o={name:r,feature_path:"".concat(r),id:t++,level:1,children:a,level1Root:r};s.push(o)}});const c={name:"root",feature_path:"root",id:t++,level:0,children:s,visible:!0};return console.log("!!!!",s),console.log("数据转换完成:",c),console.log("处理了 ".concat(s.length," 个subtree组")),g(c),y(c,h),console.log(c),c}return console.warn("数据格式不正确，使用默认数据"),i};function g(i){function h(t){if(!(!t||!t.name)){if(t.level>2&&t.level!=5){const s=t.name.replace(/\b(And|and)\b/g,"&").split(" ");let e,f=t.level==3?10:8;if(s.length<3&&s.every(l=>l.length<=f))e=s.join("\n");else{const l=(n,r)=>n.includes("-")?n.split("-").map((o,u)=>o.slice(0,r)).join("-"):n.includes("&")?n.split("&").map((o,u)=>o.slice(0,r)).join("&"):n.slice(0,r);if(s.length<=2){let n=t.level==3?4:3;e=s.map(r=>l(r,n)).join("\n")}else e=s.map(n=>l(n,1)).join("")}t.originalName=t.name,t.name=e}t.children&&Array.isArray(t.children)&&t.children.forEach(h)}}h(i)}const y=(i,h)=>{if(!i||!h){console.warn("treeData 或 mapData 为空");return}const t=e=>{e&&(p(e,h),e.children&&Array.isArray(e.children)&&e.children.forEach(f=>t(f)))},p=(e,f)=>{if(!e.feature_path){console.warn("节点缺少 feature_path:",e);return}const c=f.metadata||f,l=e.level1Root||s(e.feature_path);if(c[l]){const n=c[l];if(Array.isArray(n)){const r=n.find(a=>{if(typeof a=="object"&&a!==null){const o=a.feature_path===e.feature_path,u=a.node===e.name;return o||u}return!1});r?e.metaData=r:console.log("未找到节点 ".concat(e.name," 的匹配数据, feature_path: ").concat(e.feature_path))}else typeof n=="object"&&n[e.feature_path]&&(e.metaData=n[e.feature_path])}else console.log("未找到根键 ".concat(l," 在mapData中"))},s=e=>e&&e.split("/").find(c=>c&&c!=="root")||"";return Array.isArray(i)?i.forEach(e=>t(e)):t(i),console.log("节点数据匹配完成"),i};function _(i){if(!i.children||i.children.length===0)return 1;const h=i.children.map(t=>_(t));return 1+Math.max(...h)}export{_ as g,v as h};
