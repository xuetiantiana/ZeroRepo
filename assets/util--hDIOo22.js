const $=l=>{let s=0;const u=(t,a="root",h="",c=0)=>{const r=h?"".concat(h,"/").concat(a):a;if(Array.isArray(t))return t.map(n=>{const e=c+1;return{name:n,feature_path:"".concat(r,"/").concat(n),id:s++,level:e}});if(typeof t=="object"&&t!==null){const n=[];for(const[e,o]of Object.entries(t))if(Array.isArray(o))n.push({name:e,feature_path:"".concat(r,"/").concat(e),id:s++,level:c,children:o.map(i=>{const f=c+1;return{name:i,feature_path:"".concat(r,"/").concat(e,"/").concat(i),id:s++,level:f}})});else if(typeof o=="object"){const i=u(o,e,r,c+1);Array.isArray(i)?n.push({name:e,feature_path:"".concat(r,"/").concat(e),id:s++,level:c,children:i}):n.push({name:e,feature_path:"".concat(r,"/").concat(e),id:s++,level:c,children:i.children||[]})}return n}return{name:t,feature_path:r}};if(l&&l.subtrees&&l.subtrees.length>0){const t=[],a=["Data Engineering","Algorithms","Advanced Modeling Techniques","Workflow"];[...l.subtrees].sort((r,n)=>{const e=a.indexOf(r.name),o=a.indexOf(n.name);return e===-1&&o===-1?0:e===-1?1:o===-1?-1:e-o}).forEach((r,n)=>{if(r.refactored_subtree){const e=r.name||"Subtree_".concat(n+1),o=u(r.refactored_subtree,e,"",2),i={name:e,feature_path:"".concat(e),id:s++,level:1,children:o};t.push(i)}});const c={name:"root",feature_path:"root",id:s++,level:0,children:t,visible:!0};return console.log("!!!!",t),console.log("数据转换完成:",c),console.log("处理了 ".concat(t.length," 个subtree组")),c}return console.warn("数据格式不正确，使用默认数据"),l};function d(l){if(!l.children||l.children.length===0)return 1;const s=l.children.map(u=>d(u));return 1+Math.max(...s)}export{d as g,$ as h};
